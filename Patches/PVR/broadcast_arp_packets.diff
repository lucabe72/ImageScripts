--- linux-3.4.14/drivers/net/macvtap.c	2012-10-12 22:44:59.000000000 +0200
+++ PVRMod/macvtap.c	2013-05-25 23:06:32.146919215 +0200
@@ -246,9 +246,8 @@
  * endpoint to another one in bridge mode. We just take
  * the skb and put it into the receive queue.
  */
-static int macvtap_forward(struct net_device *dev, struct sk_buff *skb)
+static int macvtap_forward2q(struct net_device *dev, struct sk_buff *skb, struct macvtap_queue *q)
 {
-	struct macvtap_queue *q = macvtap_get_queue(dev, skb);
 	if (!q)
 		goto drop;
 
@@ -264,6 +263,43 @@
 	return NET_RX_DROP;
 }
 
+static int macvtap_forward2all(struct net_device *dev, struct sk_buff *skb)
+{
+	struct macvlan_dev *vlan = netdev_priv(dev);
+	struct macvtap_queue *tap = NULL;
+	__u32 rxq;
+
+	for (rxq = 0; rxq < MAX_MACVTAP_QUEUES; rxq++) {
+		tap = rcu_dereference(vlan->taps[rxq]);
+		if (tap) {
+			struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);
+			macvtap_forward2q(dev, skb2, tap);
+		}
+	}
+
+	kfree_skb(skb);
+	return NET_RX_SUCCESS;
+}
+
+int skb2all(struct sk_buff *skb)
+{
+	if (skb->protocol == htons(ETH_P_ARP)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static int macvtap_forward(struct net_device *dev, struct sk_buff *skb)
+{
+	if (skb2all(skb)) {
+		return macvtap_forward2all(dev, skb);
+	} else {
+		struct macvtap_queue *q = macvtap_get_queue(dev, skb);
+		return macvtap_forward2q(dev, skb, q);
+	}
+}
+
 /*
  * Receive is for data from the external interface (lowerdev),
  * in case of macvtap, we can treat that the same way as
